% vim: sw=4 ts=4 et

\chapter{Low-Frequency Oscillator}

The LFOs provide four LFO waveforms for each of three oscillators.  The waveforms are sine, ramp up/down, triangle, and square.  These are generated by a simple increasing counter; except that the sine waveform is generated with a stripped down Chamberlin SVF resonating, requiring two fused multiply-adds, plus two sample registers per LFO.

\section{Block Diagram}

\begin{figure}[h!t]
    \centering
    \input{../diagrams/lfo-block-diagram.tex}
    \caption{\label{fig:lfo-block-diagram} Block diagram of the low frequency oscillator unit.  The unit uses a Chamberlin SVF (top right) as a sine oscillator, storing $f$ in the phase increment register.}
\end{figure}

The LFO internally only generates a ramp.  The ramp and square follow the period given by the phase, with the square using the MSB of the phase as the output value.  The triangle relies on an overflow:  once the phase rolls over its 16-bit value, a 17th carry-out bit is stored in the Direction register if the waveform is triangle.  If the waveform is triangle, then the output is rendered as $(0-Phase)$.  To compensate for this, the phase increment is doubled when the waveform is triangle.

When generating a sine waveform, the LFO is programmed with the $f$ coefficient divided by $\tau$, not a frequency.  The exact computation is $f=2\sin\left(\frac{\tau F_c}{2F_s}\right)$, where $F_c$ is the oscillation frequency and $F_s$ is the sample rate.  For all other waveforms, the $f$ register is set to $f=\frac{\tau F_c}{F_s}$.  For frequencies below 300Hz, the latter computation is within .006\% of correct or .00000126Hz off when generating a sine wave, and implementations may wish to avoid a sine computation by using the simplified value of $f$.

The LFO itself contains a stripped down Chamberlin SVF oscillator to produce sine waveforms.  This avoids routing and complex decisions necessary to use the existing SVF as an oscillator.

Internally, the phase is tracked normalized to $\tau$, and the results of the prior calculations must be themselves divided by $\tau$ when setting the $f$ register; this simplifies the latter computation to $\frac{F_c}{F_s}$, or a division by 48,000 ($375 \times 2^7$).

The three LFOs can be used to modulate vibrato, duty cycle, or volume.

\section{Pipeline and Timing}

\subsection{Reading}

Reading the current LFO value only requires sending the phase accumulator's current value through an XOR, increment, and AND gate, or directly outputting the delay value for sine.  As such, reading is a single-cycle action:  the address is placed on the \texttt{Address} input, and the corresponding LFO value appears on \texttt{DataOut} on the next clock cycle.

\subsection{Writing}

The phase increment can be set at any time without a race condition, although writing during the update phase may cause some phase increment updates to occur before or after a given sample is generated.

Waveform and direction can be modified at any time, although an update should not happen between phase increment and waveform being updated when the waveform is changed to or from sine.

Reset should only be sent after update and before generation of the next sample.

To handle the latter two, all waveform, direction, and reset writes are combined and buffered, and applied directly after update.  The oscillator should be reset when changing to or from sine.

\subsection{Updating}

The LFO is updated by signaling a 1 on the \texttt{Update} input.  This sets the internal \texttt{Updating} register to 1.  Updating is deterministic:  each waveform is updated exactly one step.  Updating must be done exactly once per sample generated.

Updating is continuous.  The \texttt{Updating} register contains one bit per waveform generated.  Each cycle, the value of \texttt{Updating} is checked, the corresponding phase accumulator is incremented, and then \texttt{Updating} is shifted left by 1.  This shift sets \texttt{Updating} to zero after the last phase accumulator is incremented.

Updating the sine wave oscillator requires a multiply, which may take multiple cycles.  The number of cycles is configurable.  Upon updating a phase accumulator, the multiplies for sine and cosine is placed into a delay line.  The last element of this delay line is checked each cycle; if its \texttt{SineUpdateEnabled} value contains a 1, the sine and cosine delay elements for the corresponding oscillator are set to the outputs of the corresponding multipliers.  Each delay element is moved into the next each cycle.

This means that for $n$ LFOs with $m$ clock cycle delay for multiplication, each update requires $n+m$ cycles to complete.  \texttt{Update} must be pulled high for exactly one cycle after reading all LFOs for a given sample, and then the next sample must begin generating no sooner than once $n+m$ clock cycles have passed.

